options
{
  LOOKAHEAD = 1;
  DEBUG_PARSER = false;
  MULTI = true;
}

PARSER_BEGIN(Parser)
// Java Code to invoke the parser


import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.regex.Pattern;

public class Parser {

    static int errors = 0;

    public static void main(String args[]) throws ParseException, FileNotFoundException {

        if(args.length != 1 || !Pattern.matches(".*\\.yal$", args[0])){
            System.out.println("Usage: java Parser <file.yal>");
            System.exit(-1);
        }

        Parser parser = new Parser(new FileInputStream(args[0]));
        try{
            SimpleNode root = parser.Module();
            root.dump("");
            }
        catch (Exception e){
            e.printStackTrace(System.out);
        }

        System.out.println(".yal file parsed with " + errors + " errors");
    }
}
PARSER_END(Parser)
SKIP :
{
" "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
| <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

// reserved words (Terminals)
TOKEN :
{
<RELA_OP: ">" | "<" | "<=" | ">=" | "==" | "!=">
| <ADDSUB_OP: "+" | "-">
| <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>">
| <BITWISE_OP: "&" | "|" | "^">
| <NOT_OP: "!">
| <WHILE: "while">
| <IF: "if">
| <ELSE: "else">
| <ASSIGN: "=">
| <ASPA: "\"">
| <LPAR: "(">
| <RPAR: ")">
| <VIRG: ",">
| <PVIRG: ";">
| <LCHAVETA: "{">
| <RCHAVETA: "}">
| <FUNCTION: "function">
| <MODULE: "module">
| <SIZE: "size">
}

TOKEN :
{
<INTEGER: (<DIGIT>)+>
| <ID: <LETTER> (<LETTER> | <DIGIT>)*>
| <#LETTER: ["$","A"-"Z","_","a"-"z"]>
| <#DIGIT: ["0"-"9"]>
| <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">
}


// Production Definition (Non - Terminals)

JAVACODE

//funcao que nao consome o caracter passado por argumento
void error_skipto(int kind, String msg) {
  ParseException e = generateParseException();  // generate the exception object.
  System.out.println(msg + " - " + e.toString());  // print the error message
  errors++;
  Token t;
  while(true)
  {
    t = getToken(1);
    if(t.kind == kind | t.kind == EOF){
        return;}
    getNextToken();
  }
}

JAVACODE
//funcao que consome o carater passado por argumento
void error_skipto_andEat(int kind, String msg) {
  ParseException e = generateParseException();  // generate the exception object.
  System.out.println(msg + " - " + e.toString());  // print the error message
  errors++;
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != kind);
}


SimpleNode Module() #MOD : {Token t;}
{
    try{
     <MODULE> t = <ID> {jjtThis.value = t.image;} <LCHAVETA> (Declaration())* (Function())* <RCHAVETA>
     }
      catch(ParseException e){
         error_skipto(RCHAVETA, "MODULE");
        }
     { return jjtThis; }
}

void Declaration(): {Token t;}
{
  try{
    (Element()) (t = <ASSIGN> {jjtThis.value = t.image;} ( ArrayDeclaration() | ScalarDeclaration()))?
  }
  catch(ParseException e){
    error_skipto(PVIRG, "Declaration");
   }
   <PVIRG>
}

void Element() #ELEMENT: {Token t1;}
{
  t1 = <ID> {jjtThis.value = t1.image;} (ArrayElement())?
}

void ArrayElement() #ARR_ELEM: {}
{
  "[" "]"
}

void ScalarDeclaration() #void: {}
{
  (<ADDSUB_OP>)? <INTEGER>
}

void ArrayDeclaration() #ARR_DECL: {}
{
  ( "[" ArraySize() "]" ) 
}



void Function() #FUNCTION: {Token t1, t2;}
{
  t1 = <FUNCTION> {jjtThis.value = t1.image;}
   try{
       t2 = <ID> {jjtThis.value = t2.image;}
      }
      catch(ParseException e){
          error_skipto(LPAR, "FunctionID");
      }

   (FunctionAssign())?
    try{
        FunctionDeclaration()
    }
    catch(ParseException e){
        error_skipto(LCHAVETA, "Function");
    }
   FunctionContent()
}


void FunctionAssign() #FUNCT_ASSIGN: {Token t1, t2;}
{
    (ArrayElement())? t1 = <ASSIGN> {jjtThis.value = t1.image;} t2 = <ID> {jjtThis.value = t2.image;}
}

void FunctionDeclaration() #void: {}
{
     <LPAR> (Varlist())? <RPAR>

}

void FunctionContent() #void:{}
{
    <LCHAVETA> Stmtlst()
}

void Varlist() #void: {}
{
  (Element()) (<VIRG> (Element()))*
}

void Stmtlst() #void: {}
{
  (Stmt())* <RCHAVETA>
}

void Stmt() #void: {}
{
    While() | If() | LOOKAHEAD(3) Assign() | 
    
    try
    {
        Call() 
    }
    catch(ParseException e)
    {   
        error_skipto(PVIRG, "Stmt");
    }
    
    <PVIRG>
}

void Assign() #void: {}
{
  Lhs() <ASSIGN>

    try
    {
        Rhs()
    }
    catch(ParseException e)
    {
        error_skipto(PVIRG, "Assign");
    }

    try{
      <PVIRG>
    }
    catch(ParseException e){
      error_skipto_andEat(PVIRG, "Assign");
     }
}

void Lhs() #void: {}
{
    Access()
}

void Rhs() #void: {}
{
    ( Term() ( ( <ARITH_OP> | <BITWISE_OP> | <ADDSUB_OP> ) Term() )? ) | "[" ArraySize() "]"
}

void ArrayAccess() #ARR_ACC: {}
{
  "[" Index() "]"
}

void ScalarAccess() #SCA_ACC: {}
{
  <ID> ("." <SIZE>)?
}

void Access() #ACC: {Token t1;}
{
  t1 = <ID> {jjtThis.value = t1.image;} (("[" Index() "]") | ("." <SIZE>)?)
}

void Index() #IND: {Token t1, t2;}
{
   t1 = <ID> {jjtThis.value = t1.image;} | t2 = <INTEGER> {jjtThis.value = t2.image;}
}

void Term() #TERM: {Token t1, t2;}
{
    (t1 = <ADDSUB_OP> {jjtThis.value = t1.image;})? (t2 = <INTEGER> {jjtThis.value = t2.image;} |  LOOKAHEAD(3) Call() | Access())
}

void ArraySize() #ARR_SIZE: {Token t;}
{
    ScalarAccess() | t = <INTEGER> {jjtThis.value = t.image;}
}

void Call() #CALL:{Token t1, t2;}
{
  t1 = <ID> {jjtThis.value = t1.image;} ("." t2 = <ID> {jjtThis.value = t2.image;})? <LPAR> (ArgumentList())? <RPAR>

  //t1 = <ID> {jjtThis.value = t1.image;} ("." t2 = <ID> {jjtThis.value = t2.image;})? <LPAR> (ArgumentList())? 

  //try
  //{
  //    <RPAR>
  //}
  //catch(ParseException e)
  //{
  //    error_skipto_andEat(RPAR, "Call");
  //}
}

void ArgumentList() #void:{}
{
  Argument() (<VIRG> Argument())*
}

void Argument() #ARG:{Token t1, t2, t3;}
{
  ( t1 = <ID> {jjtThis.value = t1.image;}| t2 = <STRING> {jjtThis.value = t2.image;} | t3 = <INTEGER> {jjtThis.value = t3.image;} )
}

void While() #WHILE:{}
{
  <WHILE> Exprtest() <LCHAVETA> Stmtlst()
}

void Exprtest() #EXPR_TEST:{Token t1;}
{
  <LPAR>
  try{
    Lhs() t1 = <RELA_OP> {jjtThis.value = t1.image;} Rhs()
  }
  catch(ParseException e){
    error_skipto(RPAR, "Exprtest");
   }
  try{
   <RPAR>
   }
   catch(ParseException e){
     error_skipto_andEat(RPAR, "Exprtest");
   }

}

void If() #IF:{}
{
  <IF> Exprtest() <LCHAVETA> Stmtlst()

  try
  {
      (<ELSE> <LCHAVETA> Stmtlst())?
  }
  catch(ParseException e)
  {
      error_skipto(RCHAVETA, "If");
  }
}
