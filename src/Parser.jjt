options
{
  LOOKAHEAD = 1;
  DEBUG_PARSER = false;
}

PARSER_BEGIN(Parser)
// Java Code to invoke the parser


import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.regex.Pattern;

public class Parser {
    public static void main(String args[]) throws ParseException, FileNotFoundException {

        if(args.length != 1 || !Pattern.matches(".*\\.yal$", args[0])){
            System.out.println("Usage: java Parser <file.yal>");
            System.exit(-1);
        }

        Parser parser = new Parser(new FileInputStream(args[0]));
        try{
            SimpleNode root = parser.Module();
            }
        catch (Exception e){
            e.printStackTrace(System.out);
        }

        System.out.println(".yal file parsed successfully");
    }
}
PARSER_END(Parser)
SKIP :
{
" "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
| <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

// reserved words (Terminals)
TOKEN :
{
<RELA_OP: ">" | "<" | "<=" | ">=" | "==" | "!=">
| <ADDSUB_OP: "+" | "-">
| <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>">
| <BITWISE_OP: "&" | "|" | "^">
| <NOT_OP: "!">
| <WHILE: "while">
| <IF: "if">
| <ELSE: "else">
| <ASSIGN: "=">
| <ASPA: "\"">
| <LPAR: "(">
| <RPAR: ")">
| <VIRG: ",">
| <PVIRG: ";">
| <LCHAVETA: "{">
| <RCHAVETA: "}">
| <FUNCTION: "function">
| <MODULE: "module">
| <SIZE: "size">
}

TOKEN :
{
<INTEGER: (<DIGIT>)+>
| <ID: <LETTER> (<LETTER> | <DIGIT>)*>
| <#LETTER: ["$","A"-"Z","_","a"-"z"]>
| <#DIGIT: ["0"-"9"]>
| <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">
}


// Production Definition (Non - Terminals)

SimpleNode Module() : {Token t;}
{
     <MODULE> t = <ID> <LCHAVETA> (Declaration())* (Function())* <RCHAVETA>
     { return jjtThis; }
}

void Declaration() : {}
{
  (Element()) (<ASSIGN> ( ArrayDeclaration() | ScalarDeclaration()))? <PVIRG>
}

void Element() : {}
{
 <ID> (ArrayElement())?
}

void ArrayElement() : {}
{
  "[" "]"
}

void ScalarDeclaration() : {}
{
  (<ADDSUB_OP>)? <INTEGER>
}

void ArrayDeclaration() : {}
{
  ( "[" ArraySize() "]" )
}


//É melhor arranjar a Function(), pk ficou mto partida e depois a AST pode ficar um bocado má

void Function() : {}
{
  <FUNCTION> <ID> (FunctionAssign())? FunctionDeclaration() FunctionContent()
}


void FunctionAssign() : {}
{
    (ArrayElement())? <ASSIGN> <ID>
}

void FunctionDeclaration() : {}
{
   <LPAR> (Varlist())? <RPAR>

}

void FunctionContent():{}
{
    <LCHAVETA> Stmtlst()
}

void Varlist() : {}
{
  (Element()) (<VIRG> (Element()))*
}

void Stmtlst() : {}
{
  (Stmt())* <RCHAVETA>
}

void Stmt() : {}
{
  While() | If() | LOOKAHEAD(3) Assign() | Call() <PVIRG>
}

void Assign() : {}
{
  Lhs() <ASSIGN> Rhs() <PVIRG>
}

void Lhs() : {}
{
    Access()
}

void Rhs() : {}
{
    ( Term() ( ( <ARITH_OP> | <BITWISE_OP> | <ADDSUB_OP> ) Term() )? ) | "[" ArraySize() "]"
}

void ArrayAccess() : {}
{
  "[" Index() "]"
}

void ScalarAccess() : {}
{
  <ID> ("." <SIZE>)?
}

void Access() : {}
{
   <ID> (("[" Index() "]") | ("." <SIZE>)?)
}

void Index() : {}
{
    <ID> | <INTEGER>
}

void Term() : {}
{
    (<ADDSUB_OP>)? (<INTEGER> |  LOOKAHEAD(3) Call() | Access())
}

void ArraySize(): {}
{
    ScalarAccess() | <INTEGER>
}

void Call():{}
{
  <ID> ("." <ID>)? <LPAR> (ArgumentList())? <RPAR>
}

void ArgumentList():{}
{
  Argument() (<VIRG> Argument())*
}

void Argument():{}
{
    ( <ID> | <STRING> | <INTEGER> )
}

void While():{}
{
  <WHILE> Exprtest() <LCHAVETA> Stmtlst()
}

void Exprtest():{}
{
  <LPAR> Lhs() <RELA_OP> Rhs() <RPAR>
}

void If():{}
{
  <IF> Exprtest() <LCHAVETA> Stmtlst() (<ELSE> <LCHAVETA> Stmtlst())?
}
