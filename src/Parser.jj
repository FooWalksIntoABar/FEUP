/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Parser.jj */
/*@egen*/options
{
  LOOKAHEAD = 1;
  DEBUG_PARSER = false;
               
}

PARSER_BEGIN(Parser)
// Java Code to invoke the parser


import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.regex.Pattern;

public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTParserState jjtree = new JJTParserState();

/*@egen*/
    public static void main(String args[]) throws ParseException, FileNotFoundException {

        if(args.length != 1 || !Pattern.matches(".*\\.yal$", args[0])){
            System.out.println("Usage: java Parser <file.yal>");
            System.exit(-1);
        }

        Parser parser = new Parser(new FileInputStream(args[0]));
        try{
            SimpleNode root = parser.Module();
            root.dump("");
            }
        catch (Exception e){
            e.printStackTrace(System.out);
        }

        System.out.println(".yal file parsed successfully");
    }
}
PARSER_END(Parser)
SKIP :
{
" "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
| <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

// reserved words (Terminals)
TOKEN :
{
<RELA_OP: ">" | "<" | "<=" | ">=" | "==" | "!=">
| <ADDSUB_OP: "+" | "-">
| <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>">
| <BITWISE_OP: "&" | "|" | "^">
| <NOT_OP: "!">
| <WHILE: "while">
| <IF: "if">
| <ELSE: "else">
| <ASSIGN: "=">
| <ASPA: "\"">
| <LPAR: "(">
| <RPAR: ")">
| <VIRG: ",">
| <PVIRG: ";">
| <LCHAVETA: "{">
| <RCHAVETA: "}">
| <FUNCTION: "function">
| <MODULE: "module">
| <SIZE: "size">
}

TOKEN :
{
<INTEGER: (<DIGIT>)+>
| <ID: <LETTER> (<LETTER> | <DIGIT>)*>
| <#LETTER: ["$","A"-"Z","_","a"-"z"]>
| <#DIGIT: ["0"-"9"]>
| <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">
}


// Production Definition (Non - Terminals)

JAVACODE
void error_skipto(int kind, String msg) {/*@bgen(jjtree) error_skipto */
ASTerror_skipto jjtn000 = new ASTerror_skipto(JJTERROR_SKIPTO);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
try {
/*@egen*/
  ParseException e = generateParseException();  // generate the exception object.
  System.out.println(msg + " - " + e.toString());  // print the error message
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != kind);/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}


SimpleNode Module()      : {/*@bgen(jjtree) MOD */
                            ASTMOD jjtn000 = new ASTMOD(JJTMOD);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) MOD */
    try {
/*@egen*/
    try{
     <MODULE> t = <ID> {jjtn000.value = t.image;} <LCHAVETA> (Declaration())* (Function())* <RCHAVETA>
     }
     catch(ParseException e){
        error_skipto(RCHAVETA, "Module");
     }/*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
     }
/*@egen*/
     { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Declaration(): {/*@bgen(jjtree) Declaration */
                     ASTDeclaration jjtn000 = new ASTDeclaration(JJTDECLARATION);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Declaration */
  try {
/*@egen*/
  (Element()) (t = <ASSIGN> {jjtn000.value = t.image;} ( ArrayDeclaration() | ScalarDeclaration()))? <PVIRG>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Element()         : {/*@bgen(jjtree) ELEMENT */
                          ASTELEMENT jjtn000 = new ASTELEMENT(JJTELEMENT);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/Token t1;}
{/*@bgen(jjtree) ELEMENT */
  try {
/*@egen*/
  t1 = <ID> {jjtn000.value = t1.image;} (ArrayElement())?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ArrayElement()          : {/*@bgen(jjtree) ARR_ELEM */
  ASTARR_ELEM jjtn000 = new ASTARR_ELEM(JJTARR_ELEM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ARR_ELEM */
  try {
/*@egen*/
  "[" "]"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ScalarDeclaration()      : {}
{
  (<ADDSUB_OP>)? <INTEGER>
}

void ArrayDeclaration()          : {/*@bgen(jjtree) ARR_DECL */
  ASTARR_DECL jjtn000 = new ASTARR_DECL(JJTARR_DECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ARR_DECL */
  try {
/*@egen*/
  ( "[" ArraySize() "]" )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}


//\u00c3\u2030 melhor arranjar a Function(), pk ficou mto partida e depois a AST pode ficar um bocado m\u00c3\u00a1

void Function()          : {/*@bgen(jjtree) FUNCTION */
                            ASTFUNCTION jjtn000 = new ASTFUNCTION(JJTFUNCTION);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);
/*@egen*/Token t1, t2;}
{/*@bgen(jjtree) FUNCTION */
  try {
/*@egen*/
  t1 = <FUNCTION> {jjtn000.value = t1.image;} t2 = <ID> {jjtn000.value = t2.image;} (FunctionAssign())? FunctionDeclaration() FunctionContent()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void FunctionAssign()                : {/*@bgen(jjtree) FunctionAssign */
                                        ASTFunctionAssign jjtn000 = new ASTFunctionAssign(JJTFUNCTIONASSIGN);
                                        boolean jjtc000 = true;
                                        jjtree.openNodeScope(jjtn000);
/*@egen*/Token t1, t2;}
{/*@bgen(jjtree) FunctionAssign */
    try {
/*@egen*/
    (ArrayElement())? t1 = <ASSIGN> {jjtn000.value = t1.image;} t2 = <ID>/*@bgen(jjtree)*/
                                                                          {
                                                                            jjtree.closeNodeScope(jjtn000, true);
                                                                            jjtc000 = false;
                                                                          }
/*@egen*/ {jjtn000.value = t2.image;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void FunctionDeclaration()      : {}
{
     <LPAR> (Varlist())? <RPAR>

}

void FunctionContent()      :{}
{
    <LCHAVETA> Stmtlst()
}

void Varlist()      : {}
{
  (Element()) (<VIRG> (Element()))*
}

void Stmtlst()      : {}
{
  (Stmt())* <RCHAVETA>
}

void Stmt()      : {}
{
  While() | If() | LOOKAHEAD(3) Assign() | Call() <PVIRG>
}

void Assign()      : {}
{
  Lhs() <ASSIGN> Rhs() <PVIRG>
}

void Lhs()      : {}
{
    Access()
}

void Rhs()     : {/*@bgen(jjtree) RHS */
                  ASTRHS jjtn000 = new ASTRHS(JJTRHS);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/Token t1, t2, t3;}
{/*@bgen(jjtree) RHS */
    try {
/*@egen*/
    ( Term() ( ( t1 = <ARITH_OP> {jjtn000.value = t1.image;}  | t2 = <BITWISE_OP> {jjtn000.value = t2.image;} | t3 = <ADDSUB_OP> {jjtn000.value = t3.image;} ) Term() )? ) | "[" ArraySize() "]"/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ArrayAccess()         : {/*@bgen(jjtree) ARR_ACC */
  ASTARR_ACC jjtn000 = new ASTARR_ACC(JJTARR_ACC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ARR_ACC */
  try {
/*@egen*/
  "[" Index() "]"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ScalarAccess()         : {/*@bgen(jjtree) SCA_ACC */
  ASTSCA_ACC jjtn000 = new ASTSCA_ACC(JJTSCA_ACC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SCA_ACC */
  try {
/*@egen*/
  <ID> ("." <SIZE>)?/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Access()     : {/*@bgen(jjtree) ACC */
                     ASTACC jjtn000 = new ASTACC(JJTACC);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t1, t2;}
{/*@bgen(jjtree) ACC */
  try {
/*@egen*/
  t1 = <ID> {jjtn000.value = t1.image;} (("[" Index() "]") | ("." <SIZE>)?)/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Index()     : {/*@bgen(jjtree) IND */
                    ASTIND jjtn000 = new ASTIND(JJTIND);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/Token t1, t2;}
{/*@bgen(jjtree) IND */
    try {
/*@egen*/
    t1 = <ID>/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/ {jjtn000.value = t1.image;} | t2 = <INTEGER>/*@bgen(jjtree)*/
                                                           {
                                                             jjtree.closeNodeScope(jjtn000, true);
                                                             jjtc000 = false;
                                                           }
/*@egen*/ {jjtn000.value = t2.image;}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Term()      : {/*@bgen(jjtree) TERM */
                    ASTTERM jjtn000 = new ASTTERM(JJTTERM);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/Token t1, t2;}
{/*@bgen(jjtree) TERM */
    try {
/*@egen*/
    (t1 = <ADDSUB_OP> {jjtn000.value = t1.image;})? (t2 = <INTEGER>/*@bgen(jjtree)*/
                                                                    {
                                                                      jjtree.closeNodeScope(jjtn000, true);
                                                                      jjtc000 = false;
                                                                    }
/*@egen*/ {jjtn000.value = t2.image;} |  LOOKAHEAD(3) Call() | Access())/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ArraySize()          : {/*@bgen(jjtree) ARR_SIZE */
                             ASTARR_SIZE jjtn000 = new ASTARR_SIZE(JJTARR_SIZE);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) ARR_SIZE */
    try {
/*@egen*/
    ScalarAccess() | t = <INTEGER>/*@bgen(jjtree)*/
                                   {
                                     jjtree.closeNodeScope(jjtn000, true);
                                     jjtc000 = false;
                                   }
/*@egen*/ {jjtn000.value = t.image;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Call()      :{/*@bgen(jjtree) CALL */
                   ASTCALL jjtn000 = new ASTCALL(JJTCALL);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/Token t1, t2;}
{/*@bgen(jjtree) CALL */
  try {
/*@egen*/
  t1 = <ID> {jjtn000.value = t1.image;} ("." t2 = <ID> {jjtn000.value = t2.image;})? <LPAR> (ArgumentList())? <RPAR>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ArgumentList()      :{}
{
  Argument() (<VIRG> Argument())*
}

void Argument()     :{/*@bgen(jjtree) ARG */
                      ASTARG jjtn000 = new ASTARG(JJTARG);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/Token t1, t2, t3;}
{/*@bgen(jjtree) ARG */
    try {
/*@egen*/
    ( t1 = <ID>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ {jjtn000.value = t1.image;}| t2 = <STRING>/*@bgen(jjtree)*/
                                                           {
                                                             jjtree.closeNodeScope(jjtn000, true);
                                                             jjtc000 = false;
                                                           }
/*@egen*/ {jjtn000.value = t2.image;} | t3 = <INTEGER>/*@bgen(jjtree)*/
                                                                                                        {
                                                                                                          jjtree.closeNodeScope(jjtn000, true);
                                                                                                          jjtc000 = false;
                                                                                                        }
/*@egen*/ {jjtn000.value = t3.image;} )/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void While()       :{/*@bgen(jjtree) WHILE */
  ASTWHILE jjtn000 = new ASTWHILE(JJTWHILE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WHILE */
  try {
/*@egen*/
  <WHILE> Exprtest() <LCHAVETA> Stmtlst()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Exprtest()           :{/*@bgen(jjtree) EXPR_TEST */
                            ASTEXPR_TEST jjtn000 = new ASTEXPR_TEST(JJTEXPR_TEST);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);
/*@egen*/Token t1;}
{/*@bgen(jjtree) EXPR_TEST */
  try {
/*@egen*/
  <LPAR> Lhs() t1 = <RELA_OP> {jjtn000.value = t1.image;} Rhs() <RPAR>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void If()    :{/*@bgen(jjtree) IF */
  ASTIF jjtn000 = new ASTIF(JJTIF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IF */
  try {
/*@egen*/
  <IF> Exprtest() <LCHAVETA> Stmtlst() (<ELSE> <LCHAVETA> Stmtlst())?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}